# 联邦统计

## 1. 计算流程的抽象

横向联邦学习与横向联邦统计，虽然两种任务类型的计算的内容区别很大，但是计算的流程是类似的：
都是将计算任务分发到各个数据持有者的终端上进行计算，然后再聚合他们的计算结果，得到最终的全局结果。

我们可以看出，这个流程与Map Reduce是类似的：在各个数据持有者终端上进行计算的过程对应map，聚合他们的计算结果，得到全局结果的过程对应reduce。
在这里，我们将持有数据、执行map操作的称为客户端，将发起计算任务、执行reduce操作的称为服务端。
虽然横向联邦的计算流程与Map Reduce类似，但是它并不是真正的Map Reduce，主要的不同点有两点：一是横向联邦的计算流程中，map与reduce之间使用的是安全聚合，只能得到聚合后的结果
（以目前的安全聚合算法来说，就是各个客户端结果的加法和），并不能直接得到各个客户端的计算结果；
二是横向联邦的计算流程中，数据归各个客户端分别持有，所以传统Map Reduce中需要在各个客户端之间进行数据交换、重排序的操作都不能够实现。

综上，如果我们将客户端上进行的计算称为map，安全聚合称为aggregate，在服务端上进行的计算称为reduce，那么
横向联邦的计算流程，就可以抽象为：map -> aggregate -> reduce。


## 2. 计算任务的抽象

上面我们已经看到了，横向联邦的计算流程可以抽象为map -> aggregate -> reduce，那么一个横向联邦的计算任务
是不是也可以抽象为map -> aggregate -> reduce呢？
并不是，一个横向联邦的计算任务，会更加复杂一点。

上面抽象的计算流程，只对应了一次Map Reduce，而无论是横向联邦学习还是统计，稍微复杂一点的计算逻辑都不可能只对应于一次Map Reduce，
大部分都会对应于多次Map Reduce。当然，我们可以把任务的粒度就抽象到一次Map Reduce，但是这就需要让用户把一个完整的计算逻辑拆成
多个任务，分别提交，非常的不友好。所以，更合理的设计是一次任务包含多次Map Reduce。

那是不是一个横向联邦任务，就是多组Map Reduce呢？并不完全是。我们需要注意到，横向联邦任务中，数据是归各个客户端分别持有的，
某个客户端是否加入任务，是由客户端自身决定的；同时，横向联邦任务对于参与的客户端数量也是有要求的，根据安全聚合算法的不同，会有
一个参与数量的下限和上限。所以这就于传统的Map Reduce不同，横向联邦任务发起后，必须等待网络中的各个客户端响应，有足够多的客户端加入后，
才能开始执行任务。如果响应的客户端过多的话，还需要从中选择出一部分客户端加入任务，其他未被选择的客户端则不能参与计算。
我们将这样一个等待客户端响应并选择一部分客户端加入任务的过程，称为select。

那么，这个select过程，是不是每个任务开始时，执行一次呢？并不是这样，我们需要在每次Map Reduce开始前都进行一次select操作。
这样做的理由是，一个任务，可以包含多个Map Reduce，整个流程可能很长，这个过程中，可能有客户端会突然下线（如果客户端是手机，这种情况很常见），
也有客户端会在任务中途上线，那么，只在任务开始时select一次，对于长流程的任务来说，可能就太少了。所以，我们选择在每次Map Reduce之前，
都进行一次select操作。也就是说，每次select操作中选出的客户端，都只对应于一次Map Reduce，只需要完成这一次Map Reduce即可。
这样每个客户端的压力小了很多，不再需要保持长时间的在线，同时对于任务发起者而言，也不会出现任务执行过程中，客户端越来越少的情况。

那么我们将一个select -> map -> aggregate -> reduce的过程，称为一轮，也就是一个Round。
一个横向联邦计算任务的流程，就可以抽象为多个Round，也就是：发起任务 -> Round 1 -> Round 2 -> ... -> Round N -> 任务结束。
当然，一个完整的横向联邦计算任务，除了流程之外，还应该包含输入和输出。任务的输入，可以分为两类，一类是外部的输入，也就是各个客户端
持有的数据，这些数据，在任务定义的过程中并不能获取到他们的值，只能在运行时获取，因此在定义任务时，要采用声明式的方式来定义这些输入；
另一类是任务自带的输入，比如说联邦学习中模型的初始权重，联邦统计中用户使用的一些常量、字面量等，这些值在定义任务时，值就已经明确了。
关于任务的输出，不同的任务类型，有不同的输出。具体来说，联邦学习任务的输出就是固定的，是训练好的模型权重；联邦统计的任务输出就不固定了，
用户在编写任务时，可以根据需要来定义不同的任务输出。但是有一点需要注意的是，任务最后的输出一定要是安全的，不能泄露客户端数据的隐私，
也就是说，最后输出的值一定是要通过reduce操作生成的、“归并”过的值。

所以，对于Delta来说，需要做的就是将用户编写的任务逻辑代码（横向联邦学习，横向联邦统计），转化为上述的一个又一个Round的形式，
并实现相应的客户端、服务端和安全聚合算法，用来执行每个Round中的map、reduce、aggregate和select操作。

## 横向联邦统计的实现

在对横向联邦计算任务进行了抽象之后，如何实现横向联邦统计就很明确了：从用户编写的代码中，提取出任务的输入与输出，将用户
编写的计算逻辑，转化为一个个map与reduce的操作。
这里可能要问了，为什么只有map与reduce的操作，select与aggregate操作呢？
其实，在横向联邦统计这种任务类型中，aggregate和select操作已经预定义好了，与用户编写的代码无关，Delta会自动在合适的时机，
来执行预定好的select与aggregate操作。

### 用户如何定义横向联邦统计任务

首先，我们要解决的问题，就是用户如何编写代码，来实现他的横向联邦统计任务。关于这一点，当然是希望能最大限度地方便用户的编写。

这一点，我们从数据的角度来入手。也就是说，用户是在什么数据类型上进行统计计算的。对于统计任务来说，最常见的数据类型，就是各种表格了。
如果是一个单机的任务，用户要在表格数据上进行统计，那么他一般会使用`pandas`这个包来将数据读取成`DataFrame`，并通过`DataFrame`上的
各种算子，来对数据进行计算，最终得到他想要的结果。

那么，Delta的任务就很明确了，实现一套类似`pandas.DataFrame`的API，让用户可以像写`pandas`一样地来编写横向联邦统计任务。

### 提取任务的输入与输出


{% content-ref url="../delta-task-development/hfa-task-example.md" %}
[start-deltaboard.md](../delta-task-development/hfa-task-example.md)
{% endcontent-ref %}

首先，我们就需要提取出用户编写任务的输入与输出。

对于任务的外部输入，也就是指客户端上的数据集，我们采用声明式的方式来让用户定义（参考Example里的`dataset`方法）。对于
其他内部的输入，比如说用户写在代码里的字面量，Delta可以自动地收集这些值，将他们作为任务的内部输入。

对于任务的输出，由于我们限定了，用户需要将所有的计算逻辑都写在一个方法里（参考Example里的`execute`方法），那么这个方法的
输出，就是整个任务的输出。任务执行时，我们只需要记录下execute方法输出的变量，作为任务的输出即可。

### 将单个算子转化为map与reduce

接下来，我们看如何将单个算子，转化为map与reduce。在这里，我们说的算子，指的就是`pandas.DataFrame`上的一些方法，
比如说`sum`，`mean`，`std`等等。

首先我们要分析，一个算子，需要转化为单纯的map操作，还是map+reduce操作，还是单纯的reduce操作。是的，你没看错，
根据算子参数的不同，同一个算子，可能转化为3种不同的操作。简单来说，当一个算子，需要联合多个不同客户端上的数据进行计算时，
就需要转化为map+reduce；否则的话，如果数据在客户端上，就转化为map，如果数据在服务端上，就转化为reduce。
举一个具体的例子，比如说`mean`这个算子，我们都知道它有一个`axis`参数，用来控制是沿着表格的行求和，还是沿着列求和。
在横向联邦的场景下，每个客户端持有数据的不同行，也就是说，每个客户端数据的行不相同，但是列相同。所以，在这种情况下，
当`axis=0`时（沿着行的方向，即对DataFrame的列求均值），`mean`算子需要转化为map+reduce；当`axis=1`时（沿着列的方向，即对DataFrame的行求均值），
如果这个DataFrame在客户端上，那么`mean`就需要转化为一个map操作，如果在服务端上，就需要转化为一个reduce操作。
这里提一句，什么时候一个DataFrame，或者说数据会在服务端上，简单来说，一个map+reduce操作之后产生的结果，就位于服务端上，
当我们还需要对这个结果进行进一步的操作时，就会需要单纯的reduce操作。

接下来我们看如何将一个算子转化为map+reduce的操作。我们还是以`mean`为例。
对于单纯的map操作和单纯的reduce操作，它们都很简单，都是转化为`pandas.DataFrame.mean`就行了，比较复杂的是map+reduce操作。
我们先不考虑横向联邦的场景，就当做是一个传统的Map Reduce场景，看看要如何实现`mean`。
这还是很简单的，只需要每个map操作输出本地数据的和`sum`以及数量`count`，reduce操作汇集所有map操作的输出之后求和，
得到所有数据的和`sum'`，以及所有数据的数量`count'`，最后计算`sum' / count'`即可。
带入到横向联邦的场景下来，在横向联邦中，安全聚合会自动将所有客户端map操作的输出求和，也就是说，reduce操作可以直接获得
`sum'`以及`count'`，不需要自己进行求和操作了。那么在横向联邦统计中，`mean`算子的map操作，依然输出本地数据的和`sum`以及数量`count`，
而reduce操作的输入，就直接是所有数据的和`sum'`以及所有数据的数量`count'`了，直接计算`sum' / count'`输出即可。

从`mean`算子这个例子出发，我们可以看出，map操作可能需要输出多个值，而其对应的reduce操作的输入，就是多个客户端上map操作的输出值之和。
所以，我们可以将map操作的输出组织成一个字典，字典的里的每个值，都需要是可加的；reduce操作的输入也是个字典，这个字典与map操作输出的字典
结构完全一致，只是字典的值变成了多个客户端输出的和。

### 将多个算子串联起来

在将单个算子转化为map reduce之后，还不算完，我们还需要考虑如何将多个算子串联起来，毕竟用户编写的代码，不可能只包含一个算子。

在这里，Delta选择使用静态计算图的方式，来解决这个问题。如果用户用过Tenserflow 1.0，那应该很容易理解这个概念。
简单来说，用户编写的代码，并不是直接在Delta上执行的代码，用户编写的代码，只相当于定义了整个计算图，执行用户代码的结果，
是得到一张计算图。Delta会根据这张计算图，对它进行分析，将其转化为一系列的map与reduce操作，再插入相应的select和aggregate操作，
组成一个个Round，最后构建出整个横向联邦统计任务。

从实现上来说，用户在Delta中编写横向联邦统计的任务代码时，输入的数据结构`delta.pandas.DataFrame`，调用的是`delta.pandas.DataFrame`
上的各种算子。但实际上，`delta.pandas.DataFrame`并不包含数据，只是代表计算图上的一个数据节点。调用`delta.pandas.DataFrame`上的算子，
也只是在计算图上，添加了对应的map、reduce或者map+reduce节点。运行完用户编写的代码后，输出的数据节点，就是整个任务的输出了。
从输出节点出发进行遍历，就能得到整张计算图了。计算图中，那些没有入度的数据节点，自然就是任务的输入了。
得到计算图之后，我们需要根据计算图，来整理出任务中的每个Round。在每个Round中，都包含一个map和一个reduce操作，我们要做的，就是
将计算图上的map操作和reduce操作排好序，安排到每个Round的map和reduce中。这里需要指出的是，Round中的一个map和reduce，可以对应于计算图
中的多个map和reduce，只要这些计算图上的map或者reduce操作的输入数据在执行前已经准备完成，就可以把他们合并为一个map或者reduce操作。
构建好这些Round之后，整个任务的构建就完成了。之后我们需要做的，就是提交任务，开始执行了。

### 任务的执行

任务提交后，最后是在Delta Node的客户端与服务端上执行的。Delta Node在任务执行中，主要起两个作用：
一是与链上安全聚合系统交互，实现任务的创建、结算、以及安全聚合；二是为任务的执行提供数据。

首先看Delta Node的客户端。客户端除了监听任务创建、适时加入任务、下载任务外，在任务执行的过程中，主要执行
每个Round中的map操作。为了保证map操作能够顺利运行，需要根据map操作的输入，选择从本地加载相应的数据集、
从服务端下载所需的输入、从本地缓存中读取之前map操作的输出。map操作执行结束后，需要进行map reduce的输出，
会通过链上安全聚合提交，其他的输出，会缓存在本地，供之后的map操作使用。

其次是Delta Node的服务端。服务端除了接受用户提交的任务，将任务提交到链上安全聚合系统外，在任务的执行过程中，
主要执行每个Round的reduce操作。reduce操作的输入，除了每个Round链上安全聚合系统的输出，还有可能有一些本地缓存的数据。
reduce操作执行结束后，得到的输出会缓存在本地，以供之后的reduce操作，或者其他客户端的map操作使用。

在每个Round开始执行时，选择加入这个Round的客户端，都会通过链上安全聚合系统，尝试去加入这个Round。
服务端也会通过链上安全聚合系统，对客户端进行选择。没有被选中的客户端，会直接退出这个Round的执行。

任务所有Round都结束后，客户端与服务端都会清理本地的缓存。同时，服务端还会根据任务的输出，将缓存中对应的值保存起来，
以供用户进行下载查看。

